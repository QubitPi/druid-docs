"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[5752],{28453:(e,t,n)=>{n.d(t,{R:()=>l,x:()=>r});var a=n(96540);const s={},i=a.createContext(s);function l(e){const t=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),a.createElement(i.Provider,{value:t},e.children)}},41862:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>r,default:()=>h,frontMatter:()=>l,metadata:()=>a,toc:()=>o});const a=JSON.parse('{"id":"data-management/delete","title":"Data deletion","description":"\x3c!--","source":"@site/docs/latest/data-management/delete.md","sourceDirName":"data-management","slug":"/data-management/delete","permalink":"/docs/latest/data-management/delete","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"delete","title":"Data deletion"},"sidebar":"docs","previous":{"title":"Data updates","permalink":"/docs/latest/data-management/update"},"next":{"title":"Schema changes","permalink":"/docs/latest/data-management/schema-changes"}}');var s=n(74848),i=n(28453);const l={id:"delete",title:"Data deletion"},r=void 0,d={},o=[{value:"Delete data for a time range manually",id:"delete-data-for-a-time-range-manually",level:2},{value:"Delete data automatically using drop rules",id:"delete-data-automatically-using-drop-rules",level:2},{value:"Delete specific records",id:"delete-specific-records",level:2},{value:"Delete an entire table",id:"delete-an-entire-table",level:2},{value:"Delete data permanently using <code>kill</code> tasks",id:"delete-data-permanently-using-kill-tasks",level:2},{value:"Auto-kill data using Coordinator duties",id:"auto-kill-data-using-coordinator-duties",level:3},{value:"Auto-kill data on the Overlord (Experimental)",id:"auto-kill-data-on-the-overlord-experimental",level:3}];function c(e){const t={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h2,{id:"delete-data-for-a-time-range-manually",children:"Delete data for a time range manually"}),"\n",(0,s.jsxs)(t.p,{children:["Apache Druid stores data ",(0,s.jsx)(t.a,{href:"/docs/latest/design/storage",children:"partitioned by time chunk"})," and supports\ndeleting data for time chunks by dropping segments. This is a fast, metadata-only operation."]}),"\n",(0,s.jsx)(t.p,{children:"Deletion by time range happens in two steps:"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:["Segments to be deleted must first be marked as ",(0,s.jsx)(t.a,{href:"/docs/latest/design/storage#segment-lifecycle",children:'"unused"'}),". This can\nhappen when a segment is dropped by a ",(0,s.jsx)(t.a,{href:"/docs/latest/operations/rule-configuration",children:"drop rule"})," or when you manually mark a\nsegment unused through the Coordinator API or web console. This is a soft delete: the data is not available for\nquerying, but the segment files remains in deep storage, and the segment records remains in the metadata store."]}),"\n",(0,s.jsxs)(t.li,{children:['Once a segment is marked "unused", you can use a ',(0,s.jsxs)(t.a,{href:"#kill-task",children:[(0,s.jsx)(t.code,{children:"kill"})," task"]})," to permanently delete the segment file from\ndeep storage and remove its record from the metadata store. This is a hard delete: the data is unrecoverable unless\nyou have a backup."]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["For documentation on disabling segments using the Coordinator API, see the\n",(0,s.jsx)(t.a,{href:"/docs/latest/api-reference/legacy-metadata-api#datasources",children:"Legacy metadata API reference"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["A data deletion tutorial is available at ",(0,s.jsx)(t.a,{href:"/docs/latest/tutorials/tutorial-delete-data",children:"Tutorial: Deleting data"}),"."]}),"\n",(0,s.jsx)(t.h2,{id:"delete-data-automatically-using-drop-rules",children:"Delete data automatically using drop rules"}),"\n",(0,s.jsxs)(t.p,{children:["Druid supports ",(0,s.jsx)(t.a,{href:"/docs/latest/operations/rule-configuration",children:"load and drop rules"}),", which are used to define intervals of time\nwhere data should be preserved, and intervals where data should be discarded. Data that falls under a drop rule is\nmarked unused, in the same manner as if you ",(0,s.jsx)(t.a,{href:"#delete-data-for-a-time-range-manually",children:"manually mark that time range unused"}),". This is a\nfast, metadata-only operation."]}),"\n",(0,s.jsxs)(t.p,{children:["Data that is dropped in this way is marked unused, but remains in deep storage. To permanently delete it, use a\n",(0,s.jsxs)(t.a,{href:"#kill-task",children:[(0,s.jsx)(t.code,{children:"kill"})," task"]}),"."]}),"\n",(0,s.jsx)(t.h2,{id:"delete-specific-records",children:"Delete specific records"}),"\n",(0,s.jsxs)(t.p,{children:["Druid supports deleting specific records using ",(0,s.jsx)(t.a,{href:"/docs/latest/data-management/update#reindex",children:"reindexing"})," with a filter. The filter specifies which\ndata remains after reindexing, so it must be the inverse of the data you want to delete. Because segments must be\nrewritten to delete data in this way, it can be a time-consuming operation."]}),"\n",(0,s.jsxs)(t.p,{children:["For example, to delete records where ",(0,s.jsx)(t.code,{children:"userName"})," is ",(0,s.jsx)(t.code,{children:"'bob'"})," with native batch indexing, use a\n",(0,s.jsx)(t.a,{href:"/docs/latest/ingestion/ingestion-spec#transformspec",children:(0,s.jsx)(t.code,{children:"transformSpec"})})," with filter ",(0,s.jsx)(t.code,{children:'{"type": "not", "field": {"type": "selector", "dimension": "userName", "value": "bob"}}'}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["To delete the same records using SQL, use ",(0,s.jsx)(t.a,{href:"/docs/latest/multi-stage-query/concepts#overwrite-data-with-replace",children:"REPLACE"})," with ",(0,s.jsx)(t.code,{children:"WHERE userName <> 'bob'"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["To reindex using ",(0,s.jsx)(t.a,{href:"/docs/latest/ingestion/native-batch",children:"native batch"}),", use the ",(0,s.jsxs)(t.a,{href:"/docs/latest/ingestion/input-sources#druid-input-source",children:[(0,s.jsx)(t.code,{children:"druid"})," input\nsource"]}),". If needed,\n",(0,s.jsx)(t.a,{href:"/docs/latest/ingestion/ingestion-spec#transformspec",children:(0,s.jsx)(t.code,{children:"transformSpec"})})," can be used to filter or modify data during the\nreindexing job. To reindex with SQL, use ",(0,s.jsx)(t.a,{href:"/docs/latest/multi-stage-query/reference#replace",children:(0,s.jsx)(t.code,{children:"REPLACE <table> OVERWRITE"})}),"\nwith ",(0,s.jsx)(t.code,{children:"SELECT ... FROM <table>"}),". (Druid does not have ",(0,s.jsx)(t.code,{children:"UPDATE"})," or ",(0,s.jsx)(t.code,{children:"ALTER TABLE"})," statements.) Any SQL SELECT query can be\nused to filter, modify, or enrich the data during the reindexing job."]}),"\n",(0,s.jsxs)(t.p,{children:["Data that is deleted in this way is marked unused, but remains in deep storage. To permanently delete it, use a ",(0,s.jsxs)(t.a,{href:"#kill-task",children:[(0,s.jsx)(t.code,{children:"kill"}),"\ntask"]}),"."]}),"\n",(0,s.jsx)(t.h2,{id:"delete-an-entire-table",children:"Delete an entire table"}),"\n",(0,s.jsxs)(t.p,{children:["Deleting an entire table works the same way as ",(0,s.jsx)(t.a,{href:"#delete-data-for-a-time-range-manually",children:"deleting part of a table by time range"}),". First,\nmark all segments unused using the Coordinator API or web console. Then, optionally, delete it permanently using a\n",(0,s.jsxs)(t.a,{href:"#kill-task",children:[(0,s.jsx)(t.code,{children:"kill"})," task"]}),"."]}),"\n",(0,s.jsx)("a",{name:"kill-task"}),"\n",(0,s.jsxs)(t.h2,{id:"delete-data-permanently-using-kill-tasks",children:["Delete data permanently using ",(0,s.jsx)(t.code,{children:"kill"})," tasks"]}),"\n",(0,s.jsxs)(t.p,{children:["Data that has been overwritten or soft-deleted still remains as segments that have been marked unused. You can use a\n",(0,s.jsx)(t.code,{children:"kill"})," task to permanently delete this data."]}),"\n",(0,s.jsx)(t.p,{children:"The available grammar is:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-json",children:'{\n    "type": "kill",\n    "id": <task_id>,\n    "dataSource": <task_datasource>,\n    "interval" : <all_unused_segments_in_this_interval_will_die!>,\n    "versions" : <optional_list_of_segment_versions_to_delete_in_this_interval>,\n    "context": <task_context>,\n    "batchSize": <optional_batch_size>,\n    "limit": <optional_maximum_number_of_segments_to_delete>,\n    "maxUsedStatusLastUpdatedTime": <optional_maximum_timestamp_when_segments_were_marked_as_unused>\n}\n'})}),"\n",(0,s.jsx)(t.p,{children:"Some of the parameters used in the task payload are further explained below:"}),"\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{children:"Parameter"}),(0,s.jsx)(t.th,{children:"Default"}),(0,s.jsx)(t.th,{children:"Explanation"})]})}),(0,s.jsxs)(t.tbody,{children:[(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:(0,s.jsx)(t.code,{children:"versions"})}),(0,s.jsx)(t.td,{children:"null (all versions)"}),(0,s.jsxs)(t.td,{children:["List of segment versions within the specified ",(0,s.jsx)(t.code,{children:"interval"})," for the kill task to delete. The default behavior is to delete all unused segment versions in the specified ",(0,s.jsx)(t.code,{children:"interval"}),"."]})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:(0,s.jsx)(t.code,{children:"batchSize"})}),(0,s.jsx)(t.td,{children:"100"}),(0,s.jsxs)(t.td,{children:["Maximum number of segments that are deleted in one kill batch. Some operations on the Overlord may get stuck while a ",(0,s.jsx)(t.code,{children:"kill"})," task is in progress due to concurrency constraints (such as in ",(0,s.jsx)(t.code,{children:"TaskLockbox"}),"). Thus, a ",(0,s.jsx)(t.code,{children:"kill"})," task splits the list of unused segments to be deleted into smaller batches to yield the Overlord resources intermittently to other task operations."]})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:(0,s.jsx)(t.code,{children:"limit"})}),(0,s.jsx)(t.td,{children:"null (no limit)"}),(0,s.jsx)(t.td,{children:"Maximum number of segments for the kill task to delete."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:(0,s.jsx)(t.code,{children:"maxUsedStatusLastUpdatedTime"})}),(0,s.jsx)(t.td,{children:"null (no cutoff)"}),(0,s.jsxs)(t.td,{children:["Maximum timestamp used as a cutoff to include unused segments. The kill task only considers segments which lie in the specified ",(0,s.jsx)(t.code,{children:"interval"})," and were marked as unused no later than this time. The default behavior is to kill all unused segments in the ",(0,s.jsx)(t.code,{children:"interval"})," regardless of when they where marked as unused."]})]})]})]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"WARNING:"})," The ",(0,s.jsx)(t.code,{children:"kill"})," task permanently removes all information about the affected segments from the metadata store and\ndeep storage. This operation cannot be undone."]}),"\n",(0,s.jsx)(t.h3,{id:"auto-kill-data-using-coordinator-duties",children:"Auto-kill data using Coordinator duties"}),"\n",(0,s.jsxs)(t.p,{children:["Instead of submitting ",(0,s.jsx)(t.code,{children:"kill"})," tasks manually to permanently delete data for a given interval, you can enable auto-kill of unused segments on the Coordinator.\nThe Coordinator runs a duty periodically to identify intervals containing unused segments that are eligible for kill. It then launches a ",(0,s.jsx)(t.code,{children:"kill"})," task for each of these intervals."]}),"\n",(0,s.jsxs)(t.p,{children:["Refer to ",(0,s.jsx)(t.a,{href:"/docs/latest/configuration/#data-management",children:"Data management on the Coordinator"})," to configure auto-kill of unused segments on the Coordinator."]}),"\n",(0,s.jsx)(t.h3,{id:"auto-kill-data-on-the-overlord-experimental",children:"Auto-kill data on the Overlord (Experimental)"}),"\n",(0,s.jsxs)(t.admonition,{type:"info",children:[(0,s.jsx)(t.p,{children:"This is an experimental feature that:"}),(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["Can be used only if ",(0,s.jsx)(t.a,{href:"/docs/latest/configuration/#segment-metadata-cache-experimental",children:"segment metadata caching"})," is enabled on the Overlord."]}),"\n",(0,s.jsx)(t.li,{children:"MUST NOT be used if auto-kill of unused segments is already enabled on the Coordinator."}),"\n"]})]}),"\n",(0,s.jsx)(t.p,{children:'This is an experimental feature to run kill tasks in an "embedded" mode on the Overlord itself.'}),"\n",(0,s.jsx)(t.p,{children:"These embedded tasks offer several advantages over auto-kill performed by the Coordinator as they:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"avoid a lot of unnecessary REST API calls to the Overlord from tasks or the Coordinator."}),"\n",(0,s.jsx)(t.li,{children:"kill unused segments as soon as they become eligible."}),"\n",(0,s.jsx)(t.li,{children:"run on the Overlord and do not take up task slots."}),"\n",(0,s.jsx)(t.li,{children:"finish faster as they save on the overhead of launching a task process."}),"\n",(0,s.jsx)(t.li,{children:"kill a small number of segments per task, to ensure that locks on an interval are not held for too long."}),"\n",(0,s.jsx)(t.li,{children:"skip locked intervals to avoid head-of-line blocking in kill tasks."}),"\n",(0,s.jsx)(t.li,{children:"require little to no configuration."}),"\n",(0,s.jsx)(t.li,{children:"can keep up with a large number of unused segments in the cluster."}),"\n",(0,s.jsx)(t.li,{children:"take advantage of the segment metadata cache on the Overlord."}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["Refer to ",(0,s.jsx)(t.a,{href:"/docs/latest/configuration/#auto-kill-unused-segments-experimental",children:"Auto-kill unused segments on the Overlord"})," to configure auto-kill of unused segments on the Overlord.\nSee ",(0,s.jsx)(t.a,{href:"/docs/latest/operations/metrics#auto-kill-unused-segments",children:"Auto-kill metrics"})," for the metrics emitted by embedded kill tasks."]})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}}}]);